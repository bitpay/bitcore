#!/usr/bin/env node

'use strict';

const program = require('../ts_build/program');
const { Wallet } = require('../ts_build/wallet');
const promptly = require('promptly');

program
  .version(require('../package.json').version)
  .option('--name <name>', 'REQUIRED - Wallet Name')
  .option('--index <index>', 'REQUIRED - takes a single index or a range of indexes i.e 10-20')
  .option('--change [change]', 'optional - should derive change addresses')
  .option('--path [path]', 'optional - Custom wallet storage path')
  .option('--storageType [storageType]', 'optional - name of the database to use (default Level)')
  .parse(process.argv);

const main = async () => {
  const { name, path, storageType, index, change = false } = program;
  let addressesAndIndex = new Object();
  let wallet, startRange, endRange;

  try {
    const password = await promptly.password('Wallet Password:');
    wallet = await Wallet.loadWallet({ name, path, storageType });
    wallet = await wallet.unlock(password);

    if (!Number(index)) {
      let range = index.split('-');
      startRange = Number(range[0]);
      endRange = Number(range[1]);
    } else {
      startRange = Number(index);
      endRange = Number(index);
    }
    let keys = [];
    for (let i = startRange; i <= endRange; i++) {
      let newKeys = [];
      const newPrivateKey = await wallet.derivePrivateKey(false, i);
      const address = wallet.deriveAddress(i);
      try {
        // see if key already exists
        await wallet.storage.getKey({ address: address, name: name, encryptionKey: wallet.unlocked.encryptionKey, keepAlive: false, open: false });
      } catch (error) {
        if (error.message.includes('Key not found in database')) {
          newKeys.push(newPrivateKey);
          if (change) {
            const newChangePrivateKey = await wallet.derivePrivateKey(true, i);
            newKeys.push(newChangePrivateKey);
          }
          addressesAndIndex[i] = newKeys.map(key => key.address).join(',');
          keys = [...keys, ...newKeys];
        } else {
          console.error(error);
        }
      }
    }

    if (keys.length > 0) {
      // Update address index to highest index in existance so that old util is unaffected
      wallet.addressIndex = endRange > wallet.addressIndex ? endRange : wallet.addressIndex;
      await wallet.importKeys({ keys });
      await wallet.saveWallet();
    }
  
    if (change) {
      console.log('Change Addresses & Indexes: ', addressesAndIndex);
    } else {
      console.log('Addresses & Indexes: ', addressesAndIndex);
    }
  } catch (e) {
    console.error(e);
  }
};

main();
