#!/usr/bin/env node

'use strict';

const program = require('../ts_build/program');
const { Wallet } = require('../ts_build/wallet');
const promptly = require('promptly');
const https = require('https');

program
  .version(require('../package.json').version)
  .option('--name <name>', 'REQUIRED - Wallet Name')
  .option('--to <to>', 'REQUIRED - string address')
  .option('--amount <amount>', 'REQUIRED - number amount (in btc/bch/eth/xrp)')
  .option('--path [path]', 'optional - Custom wallet storage path')
  .option('--token [token]', 'optional - ERC-20 token to send')
  .option('--storageType [storageType]', 'optional - name of the database to use (default Level)')
  .parse(process.argv);

const main = async () => {
  const { name, path, to, amount, target, token, storageType } = program;
  let wallet;
  let data;
  try {
    data = await getCurrencies();
  } catch (err) {
    console.error(err);
  }
  const currencies = JSON.parse(data);
  try {
    wallet = await Wallet.loadWallet({ name, path, storageType });
    const chain = wallet.chain;
    const currency = token || chain;
    const { decimals } = currencies.data.find(element => element.code === currency);
    const scale = Math.pow(10, decimals);
    const lastAddress = await wallet.deriveAddress(0);
    const recipients = [{ address: to, amount: amount * scale }];
    const feeRateObject = await wallet.getNetworkFee();
    const feeRate = JSON.parse(feeRateObject).feerate || 20;
    let nonce;
    if (!['BTC', 'BCH', 'DOGE', 'LTC'].includes(chain)) {
      nonce = await wallet.getNonce();
    }
    const utxos = await wallet.getUtxosArray({watchOnly: false});
    const params = {
      feeRate,
      nonce: Number(nonce),
      utxos,
      recipients,
      from: lastAddress,
      token
    };
    let tx;
    const txTemp = await wallet.newTx(params);
    let utxosValueSum = 0;
    let inputCount = 0;
    let outputAmount = recipients[0].amount;
    if (['BTC', 'BCH', 'DOGE', 'LTC'].includes(chain)) {
      for (const utxo of utxos) {
        if (utxosValueSum < outputAmount) {
          utxosValueSum = utxosValueSum + utxo.value;
          inputCount += 1;
        }
      }
      if (utxosValueSum < outputAmount) {
        console.error('wallet input was not sufficient to cover the output amount');
        process.exit(1);
      } else {
        const estimatedBytes = txTemp.length / 2 + inputCount * (107 + 1);
        const estimatedFee = Math.ceil(estimatedBytes * feeRate);
        if (estimatedFee) {
          params.fee = estimatedFee;
        } else {
          console.error('Could not estimate the fee');
          params.fee = 1e3;
        }
      }
      tx = await wallet.newTx(params);
    } else {
      tx = txTemp;
    }
    console.log('unsignedRawTx: ', tx);
    const passphrase = await promptly.password('Wallet Password:');
    wallet = await wallet.unlock(passphrase);
    const signedTx = await wallet.signTx({ utxos, tx, passphrase });
    console.log('signedRawTx: ', signedTx);
    const confirmed = await promptly.confirm('broadcast? (y/n)');
    if (!confirmed) {
      return;
    }
    const transaction = await wallet.broadcast({ tx:signedTx });
    console.log('txid: ', transaction.txid);
    console.log('Transaction broadcasted');
  } catch (e) {
    console.error(e);
  }
};

function getCurrencies() {
  return new Promise((resolve, reject) => {
    https.get('https://bitpay.com/currencies', res => {
      if (res.statusCode !== 200) {
        reject(new Error('Request Failed'));
      }
      let data = '';
      res.on('data', (chunk) => {
        data += chunk;
      });
      res.on('end', () => resolve(data.toString()));
    });
  });
}

main();
