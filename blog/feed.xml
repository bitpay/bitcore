<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bitcore Blog</title>
    <atom:link href="http://localhost:8080/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <link>http://localhost:8080</link>
    <description>A pure, powerful blog for your daily reading.</description>
    <pubDate>Thu, 10 Apr 2014 21:00:00 -0300</pubDate>
    <generator>Wintersmith - https://github.com/jnordberg/wintersmith</generator>
    <language>en</language>
    <item>
      <title>Bitcore now has 100% Bitcoin Core test data coverage</title>
      <link>http://localhost:8080/blog/articles/bitcore-now-has-100-bitcoin-core-test-data-coverage/</link>
      <pubDate>Thu, 10 Apr 2014 21:00:00 -0300</pubDate>
      <guid isPermaLink="true">http://localhost:8080/blog/articles/bitcore-now-has-100-bitcoin-core-test-data-coverage/</guid>
      <author></author>
      <description>&lt;p&gt;We’ve achieved an important milestone in bitcore development, 
and one that we’ve been working on since we started with this open source initiative. 
That is achieving &lt;strong&gt;100% compatibility with test data from Bitcoin
Core&lt;/strong&gt;. It was hard work, but we think it’s worth it: we are now sure 
bitcore handles correctly all the edge cases and tricky input data
the same way that bitcoind does (or at least those that have test data for them). &lt;/p&gt;
&lt;p&gt;The current version of bitcore has &lt;strong&gt;2868&lt;/strong&gt; tests passing both in node
and in modern browsers (save for a few tests that make no sense for
the browser yet, like connecting to the p2p bitcoin network). We are
also looking to expand the test coverage, and welcome any contributions
to this important task. If you’ve thought about collaborating with 
bitcore but didn’t know where to start, writing tests is a good way
to internalize with the source code, learn about bitcoin, and improve
the project a lot. You can also follow &lt;a href=&quot;/blog/articles/how-to-contribute/&quot;&gt;our collaboration guide&lt;/a&gt; if
you are new to open-source contributions.&lt;/p&gt;
&lt;p&gt;While this milestone is important (test data compatibility with Bitcoin 
Core is a must for any serious bitcoin library), we’re still looking
to complete a more ambitious goal: achieving 100% code coverage 
for all our code. A good tool to measure that is &lt;a href=&quot;http://gotwarlost.github.io/istanbul/&quot;&gt;
istanbul&lt;/a&gt;. Here’s bitcore’s istanbul report:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/images/bitcore-istanbul.png&quot;&gt; &lt;/img&gt;&lt;/p&gt;
&lt;p&gt;As you can see, there’s some work to be done, but we hope you’ll help us
get there! Bitcore is a community effort and adding tests will greatly improve
the quality of the code.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>TransactionBuilder: A (hopefully) easy API to generate Bitcoin transactions</title>
      <link>http://localhost:8080/blog/articles/transactionbuilder/</link>
      <pubDate>Tue, 01 Apr 2014 21:00:00 -0300</pubDate>
      <guid isPermaLink="true">http://localhost:8080/blog/articles/transactionbuilder/</guid>
      <author></author>
      <description>&lt;p&gt;During the last few days we have been working on a new interface to generate
Bitcoin transactions. We wanted to support all standard types transactions 
(pay to pubkeyhash, pay to pubkey, pay to script and multisig)  while providing 
an easy to use API. This is how we arrived at the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Builder_pattern&quot;&gt;Builder Pattern&lt;/a&gt; 
and &lt;em&gt;TransactionBuilder&lt;/em&gt; was born.&lt;/p&gt;
&lt;p&gt;Hopefully &lt;em&gt;TransactionBuilder&lt;/em&gt; will help Javascript developers to unleash the 
power of Bitcoin.&lt;/p&gt;
&lt;h2 id=&quot;bitcoin-transactions-introduction&quot;&gt;Bitcoin Transactions Introduction&lt;/h2&gt;
&lt;p&gt;All Bitcoin transactions have inputs and outputs. The inputs are the sources of the coins the transactions are spending (i.e. transfering to the outputs). The sum of all inputs’ values  must be equal or greater than the sum of all outputs’ values. The difference, if existent, is the fee assigned by the transaction creator to the miner. This fee will be collected by miner that includes the transaction on the Bitcoin blockchain.&lt;/p&gt;
&lt;p&gt;Once the transaction is accepted on the network, the outputs are ready to become
inputs for future transactions. Unsurprisingly, each output can only be spent once, 
therefore a common name for the available outputs to became inputs is &lt;em&gt;unspent outputs&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In order to spend an &lt;em&gt;unspent output&lt;/em&gt; in a transaction, proof of ownership must be 
provided. Bitcoin implements this security mechanisim by adding a script to all 
outputs (called ScriptPubKey). This script must fulfilled to spend the associated 
output coins. Each time an unpent output has been spent in a transaction input, 
the input &lt;strong&gt;must&lt;/strong&gt; provide the right arguments to the unspent’s script (those 
arguments are a script theirself, which is called ScriptSig).  Failure to do 
this, will cause the rejection of the transaction by the network. ScriptPubKey 
and ScriptSig can be thought as a lock and a key, respectively.&lt;/p&gt;
&lt;h2 id=&quot;standard-transactions&quot;&gt;Standard Transactions&lt;/h2&gt;
&lt;p&gt;In Bitcoin standard transactions elliptic curve cryptography is used in 
ScriptPubKey and ScriptSig. The two more common ScriptPubKey types
 (&lt;em&gt;PayToPubKey&lt;/em&gt; and &lt;em&gt;PayToPubKeyHash&lt;/em&gt;) provide a public key (or its hash) 
in their contents. In order to spend the output, ScriptSig must provide 
a signature of the spending transaction using the correspoding private key.
The beauty of this mechanisim is that the private key is never revealed. 
Output’s ScriptPubKey has only the public key (or its hash) and 
Input’s ScriptSig has only a signature of the transaction and still 
the ownership verification can be accomplish by a third party
(the bitcoin network in our case). Usually, public keys hashed in
Bitcoin are represented as &lt;em&gt;addresses&lt;/em&gt;, using a custom 
&lt;a href=&quot;https://en.bitcoin.it/wiki/Base58Check_encoding&quot;&gt;Base58check encoding&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Besides PayToPubKey and PayToPubKeyHash, Bitcoin defines to more standard
transactions: &lt;em&gt;Multisig&lt;/em&gt; and &lt;em&gt;PayToScriptHash&lt;/em&gt;. Multisig is similar to the 
described schema, but generalize it by providing multiple (N) public keys 
on ScriptPubKey and asking for certain number (M) of signatures to allow 
spending the output. Examples of Multisig configurations are 2 required 
signatures out of 3 given public keys, 3 out of 5, and 2 out of 2. 
 Use cases for Multisig include shared control of coins, 2 factor 
authentication, third party arbitration, etc.&lt;/p&gt;
&lt;p&gt;Finally, in PayToScriptHash (or P2SH) ScriptPubKey just contain a 
hash of a script. In order to spend the transaction, the corresponding
 script must be provided on the input (on ScriptSig), AND that script
 must be fullfil with the signatures also included on ScriptSig.&lt;/p&gt;
&lt;h3 id=&quot;transactionbuilder&quot;&gt;TransactionBuilder&lt;/h3&gt;
&lt;p&gt;Without further do, here are some examples of using the new interface
for creating transactions:&lt;/p&gt;
&lt;p&gt;Transaction generation and signing&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; bitcore = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'bitcore'&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// for browser, check Readme and &lt;/span&gt;
                                    &lt;span class=&quot;comment&quot;&gt;// example/example.html examples.&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; Builder = bitcore.TransactionBuilder;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; tx = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Builder(opts)
    .setUnspent(utxos)
    .setOutputs(outs)
    .sign(keys)
    .build();

  &lt;span class=&quot;comment&quot;&gt;// Transaction ready for broadcast.&lt;/span&gt;
  broadcast(tx.serialize().toString(&lt;span class=&quot;string&quot;&gt;'hex'&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example, &lt;code&gt;utxos&lt;/code&gt; are the available unspent outputs for the 
transactions. The list of unspent output for a bitcoin address can 
be obtained from Bitcoin blockchain APIs, like &lt;a href=&quot;http://blockchain.info/&quot;&gt;blockchain.info&lt;/a&gt;, 
&lt;a href=&quot;http://biteasy.com/&quot;&gt;biteasy.com&lt;/a&gt;, &lt;a href=&quot;http://blockr.io/&quot;&gt;blockr.io&lt;/a&gt;, or our 
own open-sourced &lt;a href=&quot;https://github.com/bitpay/insight-api&quot;&gt;insigh-api&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;The expected format for the unspent outputs is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
    {
      &amp;quot;address&amp;quot;: &amp;quot;2Mwswt6Eih28xH8611fexpqKqJCLJMomveK&amp;quot;,
      &amp;quot;scriptPubKey&amp;quot;: &amp;quot;a91432d272ce8a9b482b363408a0b1dd28123d59c63387&amp;quot;,
      &amp;quot;txid&amp;quot;: &amp;quot;2ac165fa7a3a2b535d106a0041c7568d03b531e58aeccdd3199d7289ab12cfc1&amp;quot;,
      &amp;quot;vout&amp;quot;: 1,
      &amp;quot;amount&amp;quot;: 1.0,
      &amp;quot;confirmations&amp;quot;:7
    }
    , { ... }
]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;em&gt;outs&lt;/em&gt; defines the outputs of the transaction. Depending on the transaction type, different
elements must be provided. For a standart PayToPubKeyHash, the format is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  var outs = [{
    address:infoForP2sh.address, 
    amount:0.05,
  }, {...}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For other types, see examples below.&lt;/p&gt;
&lt;p&gt;Once the output is defined, &lt;em&gt;TransactionBuilder&lt;/em&gt; will scan the &lt;code&gt;unspent outputs&lt;/code&gt; 
to select the ones needed to fulfill the transaction output amount. Following the 
reference client implementation criteria, &lt;em&gt;TransactionBuilder&lt;/em&gt; will look first for
unspent outputs with 6 or more 
confirmations, then outputs with 1 or more confirmations will be selected and
 finally (and only if option &lt;code&gt;spendUnconfirmed: true&lt;/code&gt; was provided at &lt;code&gt;opts&lt;/code&gt;) 
outputs with 0 confirmations will be selected. Unless a fixed &lt;code&gt;fee&lt;/code&gt; was included
in &lt;code&gt;opts&lt;/code&gt;, the fee will be dynamically calculated depending the transaction size, 
using &lt;a href=&quot;https://en.bitcoin.it/wiki/Transaction_fees&quot;&gt;bitcoin guidelines&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Once the inputs, outputs and the fee are defined, &lt;em&gt;TransactionBuilder&lt;/em&gt; will add 
an output to collect the remainder amount, if any, in a remainder out. This out
 can be provided in &lt;code&gt;opts&lt;/code&gt; (see examples below), or the first input will be 
automatically selected.&lt;/p&gt;
&lt;p&gt;Other options include: &lt;code&gt;lockTime&lt;/code&gt; to set transaction’s &lt;code&gt;lock_time&lt;/code&gt;; &lt;code&gt;signhash&lt;/code&gt; 
to set the signature types, which defaults to &lt;em&gt;Transaction.SIGHASH_ALL&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;It is expected that the set of private &lt;code&gt;keys&lt;/code&gt; will the match the output’s 
ScriptPubKey to unlock them. After &lt;code&gt;.sign(keys)&lt;/code&gt; is called, &lt;code&gt;.isFullySigned()&lt;/code&gt; 
can be call to check if all inputs are properly signed. This schema work with all 
stardart type of transactions including Multisig as demostrated later.&lt;/p&gt;
&lt;p&gt;Transaction generation and later signing&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; b = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Builder(opts)
    .setUnspent(utxos)
    .setOutputs(outs);

  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; incompleteTx  = b.build();

  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!b.isFullySigned()) {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; keys = getMoreKeys();
    b.sign(keys);
  };
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; completeTx  = b.build();
  broadcast(tx.serialize().toString(&lt;span class=&quot;string&quot;&gt;'hex'&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To generate P2SH transactions, the utility &lt;code&gt;.infoForP2sh&lt;/code&gt; is provided. This
static method can help the creator to obtains a p2sh address for multisignature
transactions, and also can generate the redeem script hash.&lt;/p&gt;
&lt;p&gt;P2SH Transaction generation and later signing&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; infoForP2sh   = Builder.infoForP2sh({
    nreq    :&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, 
    pubkeys:pubkeys, 
    amount  :&lt;span class=&quot;number&quot;&gt;0.05&lt;/span&gt;,
  }, &lt;span class=&quot;string&quot;&gt;'testnet'&lt;/span&gt;);

  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; outs = [{
    address:infoForP2sh.address, 
    amount:&lt;span class=&quot;number&quot;&gt;0.05&lt;/span&gt;,
  }];

  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; map = {};
  map[p2shAddress]=infoForP2sh;

  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; info = Builder.  
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; b = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Builder(opts)
    .setUnspent(utxos)
    .setHashToScriptMap(map)
    .setOutputs(outs);

  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; incompleteTx  = b.build();

  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!b.isFullySigned()) {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; keys = getMoreKeys();
    b.sign(keys);
  };
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; completeTx  = b.build();
  broadcast(tx.serialize().toString(&lt;span class=&quot;string&quot;&gt;'hex'&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sending remainder to a defined output.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; opts = {
    remainderOut: {address: &lt;span class=&quot;string&quot;&gt;'mwZabyZXg8JzUtFX1pkGygsMJjnuqiNhgd'&lt;/span&gt;},
  };
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; tx = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Builder(opts)
    .setUnspent(utxos)
    .setOutputs(outs)
    .sign(keys)
    .build();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More examples can be seen at bitcore’s &lt;a href=&quot;https://github.com/bitpay/bitcore/tree/master/examples&quot;&gt;example path&lt;/a&gt; and also in our &lt;a href=&quot;https://github.com/bitpay/bitcore/blob/master/test/test.TransactionBuilder.js&quot;&gt;TransactionBuilder’s tests&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;—&lt;/p&gt;
&lt;p&gt;Matías Alejo García&lt;/p&gt;
&lt;p&gt;Comments? Suggestions? Please let me know at:
&lt;a href=&quot;http://twitter.com/ematiu&quot;&gt;@ematiu&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>How to Contribute to Bitcore</title>
      <link>http://localhost:8080/blog/articles/how-to-contribute/</link>
      <pubDate>Tue, 25 Mar 2014 21:00:00 -0300</pubDate>
      <guid isPermaLink="true">http://localhost:8080/blog/articles/how-to-contribute/</guid>
      <author></author>
      <description>&lt;p&gt;Are you a developer looking to learn more about bitcoin? 
Bitcore is a great opportunity to do so, and give back to
the community. At BitPay we encourage any developer to read the source 
code and help us improve it by fixing bugs, implementing
new exciting features, and testing existing code. &lt;/p&gt;
&lt;p&gt;Pull requests are the standard mechanism by which you contribute code to open-source projects.
To do so, start by forking our repo on GitHub. Go to 
&lt;a href=&quot;https://github.com/bitpay/bitcore&quot;&gt;github.com/bitpay/bitcore&lt;/a&gt;
and click the ‘Fork’ button.  You’ll get your own fork of the repository which will look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://github.com/user/bitcore
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then clone your fork on your machine:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone git@github.com:user/bitcore &amp;amp;&amp;amp; cd bitcore/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Add the official repo as a remote, to track our changes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote add bitpay git@github.com:bitpay/bitcore.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Create a new branch for the changes you are going to contribute, with a relevant name. Some examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b test/some-module
git checkout -b feature/some-new-stuff
git checkout -b fix/some-bug 
git checkout -b remove/some-file
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Work on your changes: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim somefile.txt
git add somefile.txt
git commit -a -m&amp;quot;adding somefile.txt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You don’t need to actually run this, of course :)&lt;/p&gt;
&lt;p&gt;When you think your code is ready, update your branch by 
getting the changes from the main repo first, as there may have been
changes while you were working:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull --rebase bitpay master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(You may need to solve any conflicts from the rebase at this point.)&lt;/p&gt;
&lt;p&gt;A final and important step is to run the tests and check they all pass.
This is done by running &lt;code&gt;mocha&lt;/code&gt; in the project’s directory. You’ll also 
need to check that tests pass in the browser, by running:
&lt;code&gt;grunt shell&lt;/code&gt; and opening the &lt;code&gt;bitcore/test/index.html&lt;/code&gt; file in your
browser.&lt;/p&gt;
&lt;p&gt;After that, you can push the changes to your fork, by doing:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push origin your_branch_name
git push origin feature/some-new-stuff
git push origin fix/some-bug
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally go to &lt;a href=&quot;https://github.com/bitpay/bitcore&quot;&gt;github.com/bitpay/bitcore&lt;/a&gt; in your
web browser and issue a new pull request. GitHub normally recognizes you have pending
changes in a new branch and will suggest creating the pull request. If it doesn’t, you can
always go to &lt;a href=&quot;https://github.com/bitpay/bitcore/compare&quot;&gt;github.com/bitpay/bitcore/compare&lt;/a&gt; and
choose the correct forks and branches. &lt;/p&gt;
&lt;p&gt;Main contributors will review your code and possibly ask for 
changes before your code is pulled in to the main repository. 
We’ll check that all tests pass, review the coding style, and
check for general code correctness. If everything is OK, we’ll 
merge your pull request and your code will be part of bitcore.&lt;/p&gt;
&lt;p&gt;If you have any questions feel free to post them to
&lt;a href=&quot;https://github.com/bitpay/bitcore/issues&quot;&gt;github.com/bitpay/bitcore/issues&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thanks for your time and code!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Cosign: Our Multisignature Wallet In Development</title>
      <link>http://localhost:8080/blog/articles/cosign-our-multisignature-wallet-in-development/</link>
      <pubDate>Mon, 24 Mar 2014 21:00:00 -0300</pubDate>
      <guid isPermaLink="true">http://localhost:8080/blog/articles/cosign-our-multisignature-wallet-in-development/</guid>
      <author></author>
      <description>&lt;p&gt;One of the greatest problems in bitcoin is security.
Countless individuals and companies have lost their bitcoins due to compromised private keys.
Multisignature transactions offer a solution to this problem.
They just need to be user-friendly.&lt;/p&gt;
&lt;p&gt;That is the idea behind Cosign, a multisignature wallet being developed by the Bitcore team.
It should be just as easy to spend multisignature bitcoins as regular (“single signature”) bitcoins, except other people (or computers) have to sign the transactions before they are valid.&lt;/p&gt;
&lt;p&gt;The way this works is that when someone from a, say, 3-of-5 multisignature wallet wishes to spend bitcoins, they can spend the bitcoins just like normal.
Then the partially signed transaction shows up on their cosigners’ screens, which they can choose to sign or not sign.
If three people sign the transaction, then it is broadcast to the bitcoin network.&lt;/p&gt;
&lt;p&gt;This provides another layer of protection for theft.
If your private keys are compromised, it doesn’t mean your bitcoins are stolen.
The thief has to steal your private keys and those of your cosigners before they can spend the bitcoins.&lt;/p&gt;
&lt;p&gt;Though easy to use, Cosign takes every measure to retain the full security of multisignature transactions.
There are a couple of key points that Cosign must satisfy to retain this full security:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The private keys must be generated client-side and must remain client-side. If they are ever stored remotely, they must first be encrypted with a strong password.&lt;/li&gt;
&lt;li&gt;The software must be open-source, and stored and executed client-side, so that it can be audited and cannot be changed by a third party.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Cosign takes advantage of a number of modern browser and bitcoin technologies to make this possible.
Web RTC is used to establish p2p connections between cosigners.
HTML5 local storage is used to store the wallet.
HD extended keys are used to simplify the generation of new addresses.&lt;/p&gt;
&lt;p&gt;It works like this.
Five people (or thereabouts) wish to participate in multisignature transactions where three of them (or so) are required to sign transactions.&lt;/p&gt;
&lt;p&gt;First, one of them opens up Cosign and creates a new wallet, and then shares the ID of the wallet with the four cosigners.
All of the cosigners join the wallet and generate a new extended private key, which has a corresponding extended public key.
The extended public key is shared with the others.
The extended private key is kept private.&lt;/p&gt;
&lt;p&gt;Now the cosigners can view their multisignature wallet just like a normal wallet.
The appearance and workflow of the wallet are almost exactly the same, with only one catch:
When someone wishes to send bitcoins, the bitcoins are not immediately sent.
Instead, the partially signed transaction is shared with the other cosigners.
If three of them sign it, then the transaction is complete, and can be broadcast to the bitcoin network and stored in the blockchain.&lt;/p&gt;
&lt;h2 id=&quot;mockups&quot;&gt;Mockups&lt;/h2&gt;
&lt;p&gt;Thanks to Bechi, we now have some beautiful mockups of this workflow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:8080/blog/images/cosign-1-join.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;First, one of the cosigners opens Cosign and creates a new wallet.
The wallet ID is a random number that is automatically generated.
This ID is then shared with the other cosigners so they can all visit the wallet.
The other cosigners copy+paste the ID to join the wallet, similar to sharing a Google Hangouts link.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:8080/blog/images/cosign-2-home.jpg&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;
&lt;p&gt;Upon joining a wallet, the cosigners will generate a new, random master extended private key, which will be used to generate master public keys, which are automatically shared with the other members of the wallet.
Addresses formed from these master keys can be seen in the addresses list, just like a normal bitcoin wallet.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:8080/blog/images/cosign-3-txs.jpg&quot; alt=&quot;3&quot;&gt;&lt;/p&gt;
&lt;p&gt;The transactions page is where the magic happens.
This page looks almost the same as a regular transactions page, with one key difference: When a cosigner sends bitcoins, it is regarded as “partially signed,” and shows up on the screens of the other cosigners.
The other cosigners can either choose to sign or to ignore the transaction.
If enough cosigners sign the transaction (say, three, in the case of a 3-of-5 multisig wallet), the transaction is fully signed and automatically broadcast to the bitcoin network.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:8080/blog/images/cosign-4-send.jpg&quot; alt=&quot;4&quot;&gt;&lt;/p&gt;
&lt;p&gt;When a cosigner wishes to send bitcoins, they visit the send page, just like a normal bitcoin wallet.
The only difference is that the transaction is not broadcast to the bitcoin network until sufficiently many cosigners sign the transaction.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:8080/blog/images/cosign-5-backup.jpg&quot; alt=&quot;5&quot;&gt;&lt;/p&gt;
&lt;p&gt;The wallet, which contains only the public keys of the cosigners, should be backed up in case of disaster.
So long as the wallet is backed up and at least (say) three of the cosigners have their master private keys, the bitcoins can be recovered.&lt;/p&gt;
&lt;p&gt;It’s worth discussing some of the technologies we are using to build this projects and why.&lt;/p&gt;
&lt;h2 id=&quot;hd-wallets&quot;&gt;HD Wallets&lt;/h2&gt;
&lt;p&gt;If you’ve ever considered how best to handle multisignature transactions, you’ve encountered the difficulty in sharing public keys with the cosigners.
Every time you generate a new, random private key, you have to share the corresponding public key, which is burdensome.
Either that, or you re-use the same addresses over and over again, which is terrible for privacy.&lt;/p&gt;
&lt;p&gt;HD wallets as described in &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki&quot;&gt;BIP 32&lt;/a&gt; solve this problem by allowing one master extended private key to generate, deterministically, infinitely many private/public key pairs.
Importantly, extended public keys can be derived from the master extended public key.
This means you share one extended public key with your cosigners, and there is no need to share more public keys after that.
All of the cosigners have every address that will ever be generated right from the start.
This greatly increases the ease of sharing public keys.&lt;/p&gt;
&lt;h2 id=&quot;web-rtc&quot;&gt;Web RTC&lt;/h2&gt;
&lt;p&gt;Cosign is a web application that is run locally.
By using web technologies, we’re able to make an app that can run pretty much anywhere, and can be improved and audited by a huge number of developers.
One of the neatest new pieces of technology to come to the web is &lt;a href=&quot;http://www.webrtc.org/&quot;&gt;Web RTC&lt;/a&gt;, which allows (almost) p2p connections in the browser.
The only central element of this is a server that exists solely to facilitate the creation of the p2p connection, after which the central server is no longer needed.&lt;/p&gt;
&lt;p&gt;The ultimate goal of Cosign is to have a genuinely p2p app with no need whatsoever for a central server, but that is not yet possible from the browser, so we will get as close to that as we can.&lt;/p&gt;
&lt;h2 id=&quot;html-5-local-storage&quot;&gt;HTML 5 Local Storage&lt;/h2&gt;
&lt;p&gt;Running apps in the browser used to be far more limited, but today, HTML 5 local storage allows apps to keep significant amounts of data stored locally so that no central server is required to store anything.
The public wallet (containing the public keys) is shared amongst all cosigners, as are other critical pieces of information such as unspent transaction outputs.&lt;/p&gt;
&lt;p&gt;Between Web RTC and HTML 5 local storage, it is actually possible to have a web wallet that runs locally with no need for a central server except the p2p facilitator. Oh, and one more important piece.&lt;/p&gt;
&lt;h2 id=&quot;insight-and-spv&quot;&gt;Insight and SPV&lt;/h2&gt;
&lt;p&gt;Cosign is developed by the same people that developed &lt;a href=&quot;http://insight.is/&quot;&gt;Insight&lt;/a&gt;, a powerful, open-source blockchain API and client.
Cosign uses insight to find unspent transaction outputs and broadcast transactions to the bitcoin network.
Long-term, however, we believe it will be possible to implement &lt;a href=&quot;https://en.bitcoin.it/wiki/Scalability#Simplified_payment_verification&quot;&gt;SPV&lt;/a&gt; in the browser, where the only need for a server will be to bridge the Web RTC communication protocol with the real bitcoin p2p protocol.
In the meantime, running insight locally means there is no central server except the p2p facilitator.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Cosign development is only just now getting underway.
Look forward to more discussion of the technical challenges along the way as we build the most secure wallet in the world.&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>