<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Bitcore Blog
    </title>
    <link rel="alternate" href="/blog/feed.xml" type="application/rss+xml" title="A pure, powerful blog for your daily reading.">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Ubuntu+Mono|Ubuntu:300,400,500,700,400italic,500italic,700italic|Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/blog/css/main.css">
  </head>
  <body>
    <header class="header">
      <div class="header-image"><img src="/blog/bitcore-logo.svg" alt="Bitcore"></div>
      <div class="content-wrap">
        <div class="logo">
          <h1><a href="/blog/">Bitcore Blog</a></h1>
          <p class="description">A pure, powerful blog for your daily reading.</p>
        </div>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <header>
            <p class="date"><span>18. April 2014</span></p>
            <h2><a href="/blog/articles/copay-team-broadcasts-first-p2sh-multisig-tx/">Copay Team Broadcasts First BIP32 P2SH Multisig Transaction from Tucuman, Argentina</a></h2>
            <p class="author"><span class="author">Ryan X. Charles</span>
            </p>
          </header>
          <section class="content"><p>It’s really hard to properly secure bitcoins.
It’s so hard that even the most technically adept bitcoiners sometimes get hacked and lose their bitcoins.
As bitcoin grows up to become an adult financial system, it is absolutely imperative that we end this security nightmare as quickly as possible.
That is what multisignature transactions promise to&nbsp;do.</p>
<p>The basic security problem with bitcoin is that your private keys give access to your bitcoins.
If you slip up just once and reveal your private keys, which is really easy to do (especially if you&#8217;re not trained in the art of computer security), your bitcoins can be stolen.
Many individuals and companies have lost some or all of their bitcoins this&nbsp;way.</p>
<p>Multisignature transactions offer a solution to this problem by allowing for more than one private key to control an address.
In a 2-of-2 multisignature transaction, a private key from your laptop is used to sign a transaction, and a private key from your phone must also be used to sign the same transaction.
If you slip up and reveal the private keys on your laptop, your bitcoins are still safe because the private keys on your phone haven’t been&nbsp;compromised.</p>
<p>Multisignature transactions allow, in principle, any combination of M signatures for N possible public keys.
(Note that limits in bitcoin’s architecture don’t allow very large M and N to be used.)
For instance, a company might desire to use 3-of-5 multisignature transactions to store their corporate funds.
This is where at least three people of five must sign a transaction.
If one person trips up and leaks their private keys, the company’s corporate funds are still&nbsp;safe.</p>
<p>A few weeks ago we announced a new project that we are developing called <a href="/blog/articles/cosign-our-multisignature-wallet-in-development/">Copay</a> (formerly Cosign) that should make it really easy to do multisignature transactions.
Since then, all six Copay developers have congregated in Tucuman, Argentina to build a prototype of this&nbsp;wallet.</p>
<p>Today we are happy to announce that we have successfully broadcast the first <span class="caps">BIP32</span> P2SH multisig transaction using Copay.
<a href="http://test.insight.is/tx/22ca516de52794efaec60a1dba3048152b49a3764d2e99124893ac0862cd7928">It can be viewed on Insight here.</a>
(Technical jargon “<span class="caps">BIP32</span>” and “P2SH” will be explained in future blog&nbsp;posts.)</p>
<p>Copay is not the only multisig wallet in development.
We fully support all efforts to improve the security of bitcoin, including <a href="https://www.bitgo.com/">BitGo</a>, <a href="https://cryptocorp.co/">CryptoCorp</a>, and <a href="https://greenaddress.it/en/">GreenAddress.it</a>.
We want the best security to win, which will be better for the entire bitcoin ecosystem.
Therefore, in keeping with the spirit of bitcoin, <a href="https://github.com/bitpay/copay">Copay is 100% open-source</a>, and has been since Day 1.
If our ideas are good for security, then they will be adopted by all bitcoin wallets.
We will all&nbsp;win.</p>
<p>We believe 2014 will go down in bitcoin history as the year of multisig.
May stolen bitcoins be a thing of the&nbsp;past.</p>
<p><img src="/blog/images/copay-first-transaction.jpg" alt="Copay Team"></p>
<p><a href="https://twitter.com/ryanxcharles">@ryanxcharles</a>, <a href="https://twitter.com/maraoz">@maraoz</a>, <a href="https://twitter.com/bechilandia/">@bechilandia</a>, <a href="https://twitter.com/cmgustavo83">@cmgustavo83</a>, <a href="https://twitter.com/colkito">@colkito</a>, <a href="https://twitter.com/ematiu">@ematiu</a></p>
<p><img src="/blog/images/copay-bitpay-yurii.jpg" alt="BitPay Curly"></p>
</section>
        </article>
        <article class="article">
          <header>
            <p class="date"><span>11. April 2014</span></p>
            <h2><a href="/blog/articles/bitcore-now-has-100-bitcoin-core-test-data-coverage/">Bitcore now has 100% Bitcoin Core test data coverage</a></h2>
            <p class="author"><span class="author">Manuel Araoz</span>
            </p>
          </header>
          <section class="content"><p>We’ve achieved an important milestone in bitcore development, 
and one that we’ve been working on since we started with this open source initiative. 
That is achieving <strong>100% compatibility with test data from Bitcoin
Core</strong>. It was hard work, but we think it’s worth it: we are now sure 
bitcore handles correctly all the edge cases and tricky input data
the same way that bitcoind does (or at least those that have test data for&nbsp;them). </p>
<p>The current version of bitcore has <strong>2868</strong> tests passing both in node
and in modern browsers (save for a few tests that make no sense for
the browser yet, like connecting to the p2p bitcoin network). We are
also looking to expand the test coverage, and welcome any contributions
to this important task. If you’ve thought about collaborating with 
bitcore but didn’t know where to start, writing tests is a good way
to internalize with the source code, learn about bitcoin, and improve
the project a lot. You can also follow <a href="/blog/articles/how-to-contribute/">our collaboration guide</a> if
you are new to open-source&nbsp;contributions.</p>
<p>While this milestone is important (test data compatibility with Bitcoin 
Core is a must for any serious bitcoin library), we’re still looking
to complete a more ambitious goal: achieving 100% code coverage 
for all our code. A good tool to measure that is <a href="http://gotwarlost.github.io/istanbul/">
istanbul</a>. Here’s bitcore’s istanbul&nbsp;report:</p>
<p><img src="/blog/images/bitcore-istanbul.png"> </img></p>
<p>As you can see, there’s some work to be done, but we hope you’ll help us
get there! Bitcore is a community effort and adding tests will greatly improve
the quality of the&nbsp;code.</p>
</section>
        </article>
        <article class="article">
          <header>
            <p class="date"><span>02. April 2014</span></p>
            <h2><a href="/blog/articles/transactionbuilder/">TransactionBuilder: A (hopefully) easy API to generate Bitcoin transactions</a></h2>
            <p class="author"><span class="author">Matías Alejo García</span>
            </p>
          </header>
          <section class="content"><p>During the last few days we have been working on a new interface to generate
Bitcoin transactions. We wanted to support all standard types transactions 
(pay to pubkeyhash, pay to pubkey, pay to script and multisig)  while providing 
an easy to use <span class="caps">API</span>. This is how we arrived at the 
<a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder Pattern</a> 
and <em>TransactionBuilder</em> was&nbsp;born.</p>
<p>Hopefully <em>TransactionBuilder</em> will help Javascript developers to unleash the 
power of&nbsp;Bitcoin.</p>
<h2 id="bitcoin-transactions-introduction">Bitcoin Transactions&nbsp;Introduction</h2>
<p>All Bitcoin transactions have inputs and outputs. The inputs are the sources of the coins the transactions are spending (i.e. transfering to the outputs). The sum of all inputs’ values  must be equal or greater than the sum of all outputs’ values. The difference, if existent, is the fee assigned by the transaction creator to the miner. This fee will be collected by miner that includes the transaction on the Bitcoin&nbsp;blockchain.</p>
<p>Once the transaction is accepted on the network, the outputs are ready to become
inputs for future transactions. Unsurprisingly, each output can only be spent once, 
therefore a common name for the available outputs to became inputs is <em>unspent outputs</em>.</p>
<p>In order to spend an <em>unspent output</em> in a transaction, proof of ownership must be 
provided. Bitcoin implements this security mechanisim by adding a script to all 
outputs (called ScriptPubKey). This script must fulfilled to spend the associated 
output coins. Each time an unpent output has been spent in a transaction input, 
the input <strong>must</strong> provide the right arguments to the unspent’s script (those 
arguments are a script theirself, which is called ScriptSig).  Failure to do 
this, will cause the rejection of the transaction by the network. ScriptPubKey 
and ScriptSig can be thought as a lock and a key,&nbsp;respectively.</p>
<h2 id="standard-transactions">Standard&nbsp;Transactions</h2>
<p>In Bitcoin standard transactions elliptic curve cryptography is used in 
ScriptPubKey and ScriptSig. The two more common ScriptPubKey types
 (<em>PayToPubKey</em> and <em>PayToPubKeyHash</em>) provide a public key (or its hash) 
in their contents. In order to spend the output, ScriptSig must provide 
a signature of the spending transaction using the correspoding private key.
The beauty of this mechanisim is that the private key is never revealed. 
Output’s ScriptPubKey has only the public key (or its hash) and 
Input’s ScriptSig has only a signature of the transaction and still 
the ownership verification can be accomplish by a third party
(the bitcoin network in our case). Usually, public keys hashed in
Bitcoin are represented as <em>addresses</em>, using a custom 
<a href="https://en.bitcoin.it/wiki/Base58Check_encoding">Base58check encoding</a>.</p>
<p>Besides PayToPubKey and PayToPubKeyHash, Bitcoin defines to more standard
transactions: <em>Multisig</em> and <em>PayToScriptHash</em>. Multisig is similar to the 
described schema, but generalize it by providing multiple (N) public keys 
on ScriptPubKey and asking for certain number (M) of signatures to allow 
spending the output. Examples of Multisig configurations are 2 required 
signatures out of 3 given public keys, 3 out of 5, and 2 out of 2. 
 Use cases for Multisig include shared control of coins, 2 factor 
authentication, third party arbitration,&nbsp;etc.</p>
<p>Finally, in PayToScriptHash (or <span class="caps">P2SH</span>) ScriptPubKey just contain a 
hash of a script. In order to spend the transaction, the corresponding
 script must be provided on the input (on ScriptSig), AND that script
 must be fullfil with the signatures also included on&nbsp;ScriptSig.</p>
<h3 id="transactionbuilder">TransactionBuilder</h3>
<p>Without further do, here are some examples of using the new interface
for creating&nbsp;transactions:</p>
<p>Transaction generation and&nbsp;signing</p>
<pre><code class="lang-js">  <span class="keyword">var</span> bitcore = <span class="built_in">require</span>(<span class="string">'bitcore'</span>); <span class="comment">// for browser, check Readme and </span>
                                    <span class="comment">// example/example.html examples.</span>
  <span class="keyword">var</span> Builder = bitcore.TransactionBuilder;
  <span class="keyword">var</span> tx = <span class="keyword">new</span> Builder(opts)
    .setUnspent(utxos)
    .setOutputs(outs)
    .sign(keys)
    .build();

  <span class="comment">// Transaction ready for broadcast.</span>
  broadcast(tx.serialize().toString(<span class="string">'hex'</span>));
</code></pre>
<p>In the example, <code>utxos</code> are the available unspent outputs for the 
transactions. The list of unspent output for a bitcoin address can 
be obtained from Bitcoin blockchain APIs, like <a href="http://blockchain.info/">blockchain.info</a>, 
<a href="http://biteasy.com/">biteasy.com</a>, <a href="http://blockr.io/">blockr.io</a>, or our 
own open-sourced <a href="https://github.com/bitpay/insight-api">insigh-api</a>. </p>
<p>The expected format for the unspent outputs&nbsp;is:</p>
<pre><code>[
    {
      &quot;address&quot;: &quot;2Mwswt6Eih28xH8611fexpqKqJCLJMomveK&quot;,
      &quot;scriptPubKey&quot;: &quot;a91432d272ce8a9b482b363408a0b1dd28123d59c63387&quot;,
      &quot;txid&quot;: &quot;2ac165fa7a3a2b535d106a0041c7568d03b531e58aeccdd3199d7289ab12cfc1&quot;,
      &quot;vout&quot;: 1,
      &quot;amount&quot;: 1.0,
      &quot;confirmations&quot;:7
    }
    , { ... }
]
</code></pre><p>The <em>outs</em> defines the outputs of the transaction. Depending on the transaction type, different
elements must be provided. For a standart PayToPubKeyHash, the format&nbsp;is:</p>
<pre><code>  var outs = [{
    address:infoForP2sh.address, 
    amount:0.05,
  }, {...}];
</code></pre><p>For other types, see examples&nbsp;below.</p>
<p>Once the output is defined, <em>TransactionBuilder</em> will scan the <code>unspent outputs</code> 
to select the ones needed to fulfill the transaction output amount. Following the 
reference client implementation criteria, <em>TransactionBuilder</em> will look first for
unspent outputs with 6 or more 
confirmations, then outputs with 1 or more confirmations will be selected and
 finally (and only if option <code>spendUnconfirmed: true</code> was provided at <code>opts</code>) 
outputs with 0 confirmations will be selected. Unless a fixed <code>fee</code> was included
in <code>opts</code>, the fee will be dynamically calculated depending the transaction size, 
using <a href="https://en.bitcoin.it/wiki/Transaction_fees">bitcoin guidelines</a>.</p>
<p>Once the inputs, outputs and the fee are defined, <em>TransactionBuilder</em> will add 
an output to collect the remainder amount, if any, in a remainder out. This out
 can be provided in <code>opts</code> (see examples below), or the first input will be 
automatically&nbsp;selected.</p>
<p>Other options include: <code>lockTime</code> to set transaction’s <code>lock_time</code>; <code>signhash</code> 
to set the signature types, which defaults to <em>Transaction.SIGHASH_ALL</em>.</p>
<p>It is expected that the set of private <code>keys</code> will the match the output’s 
ScriptPubKey to unlock them. After <code>.sign(keys)</code> is called, <code>.isFullySigned()</code> 
can be call to check if all inputs are properly signed. This schema work with all 
stardart type of transactions including Multisig as demostrated&nbsp;later.</p>
<p>Transaction generation and later&nbsp;signing</p>
<pre><code class="lang-js">  <span class="keyword">var</span> b = <span class="keyword">new</span> Builder(opts)
    .setUnspent(utxos)
    .setOutputs(outs);

  <span class="keyword">var</span> incompleteTx  = b.build();

  <span class="keyword">while</span>(!b.isFullySigned()) {
    <span class="keyword">var</span> keys = getMoreKeys();
    b.sign(keys);
  };
  <span class="keyword">var</span> completeTx  = b.build();
  broadcast(tx.serialize().toString(<span class="string">'hex'</span>));
</code></pre>
<p>To generate <span class="caps">P2SH</span> transactions, the utility <code>.infoForP2sh</code> is provided. This
static method can help the creator to obtains a p2sh address for multisignature
transactions, and also can generate the redeem script&nbsp;hash.</p>
<p><span class="caps">P2SH</span> Transaction generation and later&nbsp;signing</p>
<pre><code class="lang-js">
  <span class="keyword">var</span> infoForP2sh   = Builder.infoForP2sh({
    nreq    :<span class="number">3</span>, 
    pubkeys:pubkeys, 
    amount  :<span class="number">0.05</span>,
  }, <span class="string">'testnet'</span>);

  <span class="keyword">var</span> outs = [{
    address:infoForP2sh.address, 
    amount:<span class="number">0.05</span>,
  }];

  <span class="keyword">var</span> map = {};
  map[p2shAddress]=infoForP2sh;

  <span class="keyword">var</span> info = Builder.  
  <span class="keyword">var</span> b = <span class="keyword">new</span> Builder(opts)
    .setUnspent(utxos)
    .setHashToScriptMap(map)
    .setOutputs(outs);

  <span class="keyword">var</span> incompleteTx  = b.build();

  <span class="keyword">while</span>(!b.isFullySigned()) {
    <span class="keyword">var</span> keys = getMoreKeys();
    b.sign(keys);
  };
  <span class="keyword">var</span> completeTx  = b.build();
  broadcast(tx.serialize().toString(<span class="string">'hex'</span>));
</code></pre>
<p>Sending remainder to a defined&nbsp;output.</p>
<pre><code class="lang-js">  <span class="keyword">var</span> opts = {
    remainderOut: {address: <span class="string">'mwZabyZXg8JzUtFX1pkGygsMJjnuqiNhgd'</span>},
  };
  <span class="keyword">var</span> tx = <span class="keyword">new</span> Builder(opts)
    .setUnspent(utxos)
    .setOutputs(outs)
    .sign(keys)
    .build();
</code></pre>
<p>More examples can be seen at bitcore’s <a href="https://github.com/bitpay/bitcore/tree/master/examples">example path</a> and also in our <a href="https://github.com/bitpay/bitcore/blob/master/test/test.TransactionBuilder.js">TransactionBuilder’s&nbsp;tests</a></p>
<p>—</p>
<p>Matías Alejo&nbsp;García</p>
<p>Comments? Suggestions? Please let me know at:
<a href="http://twitter.com/ematiu">@ematiu</a></p>
</section>
        </article>
        <article class="article">
          <header>
            <p class="date"><span>26. March 2014</span></p>
            <h2><a href="/blog/articles/how-to-contribute/">How to Contribute to Bitcore</a></h2>
            <p class="author"><span class="author">Manuel Araoz</span>
            </p>
          </header>
          <section class="content"><p>Are you a developer looking to learn more about bitcoin? 
Bitcore is a great opportunity to do so, and give back to
the community. At BitPay we encourage any developer to read the source 
code and help us improve it by fixing bugs, implementing
new exciting features, and testing existing&nbsp;code. </p>
<p>Pull requests are the standard mechanism by which you contribute code to open-source projects.
To do so, start by forking our repo on GitHub. Go to 
<a href="https://github.com/bitpay/bitcore">github.com/bitpay/bitcore</a>
and click the ‘Fork’ button.  You’ll get your own fork of the repository which will look something like&nbsp;this:</p>
<pre><code>https://github.com/user/bitcore
</code></pre><p>Then clone your fork on your&nbsp;machine:</p>
<pre><code>git clone git@github.com:user/bitcore &amp;&amp; cd bitcore/
</code></pre><p>Add the official repo as a remote, to track our&nbsp;changes:</p>
<pre><code>git remote add bitpay git@github.com:bitpay/bitcore.git
</code></pre><p>Create a new branch for the changes you are going to contribute, with a relevant name. Some&nbsp;examples:</p>
<pre><code>git checkout -b test/some-module
git checkout -b feature/some-new-stuff
git checkout -b fix/some-bug 
git checkout -b remove/some-file
</code></pre><p>Work on your&nbsp;changes: </p>
<pre><code>vim somefile.txt
git add somefile.txt
git commit -a -m&quot;adding somefile.txt&quot;
</code></pre><p>You don’t need to actually run this, of course&nbsp;:)</p>
<p>When you think your code is ready, update your branch by 
getting the changes from the main repo first, as there may have been
changes while you were&nbsp;working:</p>
<pre><code>git pull --rebase bitpay master
</code></pre><p>(You may need to solve any conflicts from the rebase at this&nbsp;point.)</p>
<p>A final and important step is to run the tests and check they all pass.
This is done by running <code>mocha</code> in the project’s directory. You’ll also 
need to check that tests pass in the browser, by running:
<code>grunt shell</code> and opening the <code>bitcore/test/index.html</code> file in your&nbsp;browser.</p>
<p>After that, you can push the changes to your fork, by&nbsp;doing:</p>
<pre><code>git push origin your_branch_name
git push origin feature/some-new-stuff
git push origin fix/some-bug
</code></pre><p>Finally go to <a href="https://github.com/bitpay/bitcore">github.com/bitpay/bitcore</a> in your
web browser and issue a new pull request. GitHub normally recognizes you have pending
changes in a new branch and will suggest creating the pull request. If it doesn’t, you can
always go to <a href="https://github.com/bitpay/bitcore/compare">github.com/bitpay/bitcore/compare</a> and
choose the correct forks and&nbsp;branches. </p>
<p>Main contributors will review your code and possibly ask for 
changes before your code is pulled in to the main repository. 
We’ll check that all tests pass, review the coding style, and
check for general code correctness. If everything is <span class="caps">OK</span>, we’ll 
merge your pull request and your code will be part of&nbsp;bitcore.</p>
<p>If you have any questions feel free to post them to
<a href="https://github.com/bitpay/bitcore/issues">github.com/bitpay/bitcore/issues</a>.</p>
<p>Thanks for your time and&nbsp;code!</p>
</section>
        </article>
        <article class="article">
          <header>
            <p class="date"><span>25. March 2014</span></p>
            <h2><a href="/blog/articles/cosign-our-multisignature-wallet-in-development/">Cosign: Our Multisignature Wallet In Development</a></h2>
            <p class="author"><span class="author">Ryan X. Charles</span>
            </p>
          </header>
          <section class="content"><p>One of the greatest problems in bitcoin is security.
Countless individuals and companies have lost their bitcoins due to compromised private keys.
Multisignature transactions offer a solution to this problem.
They just need to be&nbsp;user-friendly.</p>
<p>That is the idea behind Cosign, a multisignature wallet being developed by the Bitcore team.
It should be just as easy to spend multisignature bitcoins as regular (“single signature”) bitcoins, except other people (or computers) have to sign the transactions before they are&nbsp;valid.</p>
<p>The way this works is that when someone from a, say, 3-of-5 multisignature wallet wishes to spend bitcoins, they can spend the bitcoins just like normal.
Then the partially signed transaction shows up on their cosigners’ screens, which they can choose to sign or not sign.
If three people sign the transaction, then it is broadcast to the bitcoin&nbsp;network.</p>
<p>This provides another layer of protection for theft.
If your private keys are compromised, it doesn’t mean your bitcoins are stolen.
The thief has to steal your private keys and those of your cosigners before they can spend the&nbsp;bitcoins.</p>
<p>Though easy to use, Cosign takes every measure to retain the full security of multisignature transactions.
There are a couple of key points that Cosign must satisfy to retain this full&nbsp;security:</p>
<ol>
<li>The private keys must be generated client-side and must remain client-side. If they are ever stored remotely, they must first be encrypted with a strong&nbsp;password.</li>
<li>The software must be open-source, and stored and executed client-side, so that it can be audited and cannot be changed by a third&nbsp;party.</li>
</ol>
<p>Cosign takes advantage of a number of modern browser and bitcoin technologies to make this possible.
Web <span class="caps">RTC</span> is used to establish p2p connections between cosigners.
HTML5 local storage is used to store the wallet.
HD extended keys are used to simplify the generation of new&nbsp;addresses.</p>
<p>It works like this.
Five people (or thereabouts) wish to participate in multisignature transactions where three of them (or so) are required to sign&nbsp;transactions.</p>
<p>First, one of them opens up Cosign and creates a new wallet, and then shares the <span class="caps">ID</span> of the wallet with the four cosigners.
All of the cosigners join the wallet and generate a new extended private key, which has a corresponding extended public key.
The extended public key is shared with the others.
The extended private key is kept&nbsp;private.</p>
<p>Now the cosigners can view their multisignature wallet just like a normal wallet.
The appearance and workflow of the wallet are almost exactly the same, with only one catch:
When someone wishes to send bitcoins, the bitcoins are not immediately sent.
Instead, the partially signed transaction is shared with the other cosigners.
If three of them sign it, then the transaction is complete, and can be broadcast to the bitcoin network and stored in the&nbsp;blockchain.</p>
<h2 id="mockups">Mockups</h2>
<p>Thanks to Bechi, we now have some beautiful mockups of this&nbsp;workflow.</p>
<p><img src="/blog/images/cosign-1-join.jpg" alt="1"></p>
<p>First, one of the cosigners opens Cosign and creates a new wallet.
The wallet <span class="caps">ID</span> is a random number that is automatically generated.
This ID is then shared with the other cosigners so they can all visit the wallet.
The other cosigners copy+paste the ID to join the wallet, similar to sharing a Google Hangouts&nbsp;link.</p>
<p><img src="/blog/images/cosign-2-home.jpg" alt="2"></p>
<p>Upon joining a wallet, the cosigners will generate a new, random master extended private key, which will be used to generate master public keys, which are automatically shared with the other members of the wallet.
Addresses formed from these master keys can be seen in the addresses list, just like a normal bitcoin&nbsp;wallet.</p>
<p><img src="/blog/images/cosign-3-txs.jpg" alt="3"></p>
<p>The transactions page is where the magic happens.
This page looks almost the same as a regular transactions page, with one key difference: When a cosigner sends bitcoins, it is regarded as “partially signed,” and shows up on the screens of the other cosigners.
The other cosigners can either choose to sign or to ignore the transaction.
If enough cosigners sign the transaction (say, three, in the case of a 3-of-5 multisig wallet), the transaction is fully signed and automatically broadcast to the bitcoin&nbsp;network.</p>
<p><img src="/blog/images/cosign-4-send.jpg" alt="4"></p>
<p>When a cosigner wishes to send bitcoins, they visit the send page, just like a normal bitcoin wallet.
The only difference is that the transaction is not broadcast to the bitcoin network until sufficiently many cosigners sign the&nbsp;transaction.</p>
<p><img src="/blog/images/cosign-5-backup.jpg" alt="5"></p>
<p>The wallet, which contains only the public keys of the cosigners, should be backed up in case of disaster.
So long as the wallet is backed up and at least (say) three of the cosigners have their master private keys, the bitcoins can be&nbsp;recovered.</p>
<p>It’s worth discussing some of the technologies we are using to build this projects and&nbsp;why.</p>
<h2 id="hd-wallets"><span class="caps">HD</span>&nbsp;Wallets</h2>
<p>If you’ve ever considered how best to handle multisignature transactions, you’ve encountered the difficulty in sharing public keys with the cosigners.
Every time you generate a new, random private key, you have to share the corresponding public key, which is burdensome.
Either that, or you re-use the same addresses over and over again, which is terrible for&nbsp;privacy.</p>
<p><span class="caps">HD</span> wallets as described in <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki"><span class="caps">BIP</span> 32</a> solve this problem by allowing one master extended private key to generate, deterministically, infinitely many private/public key pairs.
Importantly, extended public keys can be derived from the master extended public key.
This means you share one extended public key with your cosigners, and there is no need to share more public keys after that.
All of the cosigners have every address that will ever be generated right from the start.
This greatly increases the ease of sharing public&nbsp;keys.</p>
<h2 id="web-rtc">Web&nbsp;<span class="caps">RTC</span></h2>
<p>Cosign is a web application that is run locally.
By using web technologies, we’re able to make an app that can run pretty much anywhere, and can be improved and audited by a huge number of developers.
One of the neatest new pieces of technology to come to the web is <a href="http://www.webrtc.org/">Web <span class="caps">RTC</span></a>, which allows (almost) p2p connections in the browser.
The only central element of this is a server that exists solely to facilitate the creation of the p2p connection, after which the central server is no longer&nbsp;needed.</p>
<p>The ultimate goal of Cosign is to have a genuinely p2p app with no need whatsoever for a central server, but that is not yet possible from the browser, so we will get as close to that as we&nbsp;can.</p>
<h2 id="html-5-local-storage"><span class="caps">HTML</span> 5 Local&nbsp;Storage</h2>
<p>Running apps in the browser used to be far more limited, but today, <span class="caps">HTML</span> 5 local storage allows apps to keep significant amounts of data stored locally so that no central server is required to store anything.
The public wallet (containing the public keys) is shared amongst all cosigners, as are other critical pieces of information such as unspent transaction&nbsp;outputs.</p>
<p>Between Web <span class="caps">RTC</span> and HTML 5 local storage, it is actually possible to have a web wallet that runs locally with no need for a central server except the p2p facilitator. Oh, and one more important&nbsp;piece.</p>
<h2 id="insight-and-spv">Insight and&nbsp;<span class="caps">SPV</span></h2>
<p>Cosign is developed by the same people that developed <a href="http://insight.is/">Insight</a>, a powerful, open-source blockchain <span class="caps">API</span> and client.
Cosign uses insight to find unspent transaction outputs and broadcast transactions to the bitcoin network.
Long-term, however, we believe it will be possible to implement <a href="https://en.bitcoin.it/wiki/Scalability#Simplified_payment_verification"><span class="caps">SPV</span></a> in the browser, where the only need for a server will be to bridge the Web <span class="caps">RTC</span> communication protocol with the real bitcoin p2p protocol.
In the meantime, running insight locally means there is no central server except the p2p&nbsp;facilitator.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Cosign development is only just now getting underway.
Look forward to more discussion of the technical challenges along the way as we build the most secure wallet in the&nbsp;world.</p>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/blog/archive.html">« Archives</a>
        </div>
        <section class="about"><p><a href="http://bitcore.io/">Bitcore</a> is an open-source implementation of bitcoin in javascript that works both in node and the browser.
Our goal is to make it as easy as possible to develop apps for bitcoin.</p>

        </section>
        <section class="copy">
          <p>&copy; 2014 Bitcore Team. Blog powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith.</a>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>